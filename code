#include <iostream>
#include <stdio.h>
#include <stdlib.h>
#include <fstream>
#include <time.h>
#include <cmath>
#include <vector>
#define POPULATION_SIZE 200
#define MAX_ITERATION 200
#define TOURNAMENT_SIZE 20
#define CPX_PROB 0.8
#define MUT_PROB 0.5
using namespace std;

double bestChr = 1000000000000;
int *selectedParents;
int *fitness_array;//[POPULATION_SIZE];
int **mating_pool;
int **adjacency;
int *bestOne;
int *arr;
int optimal;
int best;
int nodes,edges;
int neighb_node1;
int neighb_node2;
ifstream gc_file;
int fitness(int*);
char *fname;
ifstream tspfile_file;
void fetch();
void generate_population();
void selection();
void crossover();
void mutation();
void print();
int greedy();

int main(int argc,char *argv[])
{
    fname=argv[1];
	srand(time(0));
	fetch();
	generate_population();
	for (int i = 0; i<MAX_ITERATION; i++)
	{
		selection();
		crossover();
		mutation();
	}
	print();
}

void fetch()
{
    gc_file.open(fname);
	gc_file >> nodes;
	gc_file >> edges;
	adjacency=new int*[nodes];
	for (int i=0; i<nodes; i++)
      adjacency[i]=new int[nodes];

    for(int i=0; i<nodes;i++)
    {
        for(int j=0; j<nodes; j++)
        {
            adjacency[i][j]=0;    //once tum elemanlarini sifra esitliyoruz
        }
    }

    for(int i=0; i < edges; i++)
    {
        gc_file>>neighb_node1;
        gc_file>>neighb_node2;
        adjacency[neighb_node1][neighb_node2]=1;    //node-lar arasinda link olusturuyor
        adjacency[neighb_node2][neighb_node1]=1;
    }
    gc_file.close();

    best=greedy();       ////max color sayisini bulduk
	bestOne = new int[nodes];
	fitness_array = new int[POPULATION_SIZE];
	selectedParents = new int[POPULATION_SIZE];

	mating_pool = new int*[POPULATION_SIZE];
	for (int i = 0; i<POPULATION_SIZE; i++)
	{
		mating_pool[i] = new int[nodes];
	}
}
void generate_population()
{
	int i, j;
	int mut1, mut2;
	double mem1,mem2,temp;
	for(i=0;i<nodes;i++)
        mating_pool[0][i]=arr[i];
    fitness_array[0]=fitness(mating_pool[0]);

    for(i=0;i<POPULATION_SIZE-1;i++)
    {
        mut1=rand()%nodes;
        mut2=rand()%nodes;

        mem1=arr[mut1];
        mem2=arr[mut2];

        temp=arr[mut1];
        arr[mut1]=arr[mut2];
        arr[mut2]=temp;

        for(j=0;j<nodes;j++)
            mating_pool[i+1][j]=arr[j];

        arr[mut1]=mem1;
        arr[mut2]=mem2;
        fitness_array[i+1]=fitness(mating_pool[i+1]);

    }

    optimal=0;
    for (i = 1; i<POPULATION_SIZE; i++)
        if (fitness_array[i]<optimal)
            optimal=i;
    if(fitness_array[optimal]<=best)
    {
        for(j=0; j<nodes; j++)
            bestOne[j]=mating_pool[optimal][j];
        best=fitness_array[optimal];
    }
}
void selection()
{
	int i, j, optimal, temp;

    for (i = 0; i<POPULATION_SIZE; i++)
        fitness_array[i]=fitness(mating_pool[i]);

    optimal=0;
    for (i = 1; i<POPULATION_SIZE; i++)
        if (fitness_array[i]<optimal)
            optimal=i;

    if(fitness_array[optimal]<=best)
    {
        for(j=0; j<nodes; j++)
            bestOne[j]=mating_pool[optimal][j];
        best=fitness_array[optimal];
    }

	for (i = 0; i<POPULATION_SIZE; i++)
	{
		optimal = rand() % POPULATION_SIZE;
		for (j = 0; j<TOURNAMENT_SIZE; j++)
		{
			temp = rand() % POPULATION_SIZE;
			if (fitness_array[temp]<fitness_array[optimal])
				optimal = temp;
		}
		selectedParents[i] = optimal;
	}
	for (i = 0; i<POPULATION_SIZE; i++)
	{
		for (j = 0; j<nodes; j++)
			mating_pool[i][j] = mating_pool[selectedParents[i]][j];
		fitness_array[i] = fitness(mating_pool[i]);
	}
}

void crossover()
{
	int temp_deger = 0;
	int i;

	int cut1 = nodes / 3;
	int cut2 = nodes * 2 / 3;

	for (i = 0; i<POPULATION_SIZE - 1;i = i + 2)
	{
	    std::vector<int> rv1;
	    std::vector<int> rv2;
		double p = (double)rand() / RAND_MAX;
		if (p<CPX_PROB)
		{
			for (int cutting = cut1; cutting<cut2; cutting++)
			{
				temp_deger = mating_pool[i][cutting];
				mating_pool[i][cutting] = mating_pool[i + 1][cutting];
				mating_pool[i + 1][cutting] = temp_deger;
			}
		}
	}

}

void mutation()
{
	double p;
	int i;
	int node1, node2, temp;
	for (i = 0; i<POPULATION_SIZE; i++)
	{
		p = (double)rand() / RAND_MAX;
		if (p<MUT_PROB)
		{
		    do
			{
			    node1 = rand() % nodes;
                node2 = rand() % nodes;
			} while (node1==node2);

			temp = mating_pool[i][node1];
			mating_pool[i][node1] = mating_pool[i][node2];
			mating_pool[i][node2] = temp;
		}
	}
}

int fitness(int *arr)
{
	bool flag=false;
	int tot_fitness=0;
	int color=0;
	vector <int> history;
	for(int i=0; i<nodes; i++)
    {
        for(int j=i+1; j<nodes; j++)
        {
            if ((adjacency[i][j]==1 )&& (arr[i]==arr[j]))
            {
                tot_fitness=1000000;  ////very large number
                break;
            }
        }
    }
    if(tot_fitness==0)
    for(int i=0; i< nodes; i++)
    {
        flag=false;
        for (int j=0; j<(int)history.size(); j++)
        {
            if (arr[i]==history[j])
            {
                flag=true;
                break;
            }
        }
        if (!flag)
        {
            color++;
            history.push_back(arr[i]);
        }
    }
    history.clear();
    if(tot_fitness>0)
        return tot_fitness;
    else
        return color;
}

void print()
{
	cout <<best<< endl;
    for (int i = 0; i<nodes; i++)
        cout<<bestOne[i]<<" ";
    cout << endl;
}

int greedy()
{
    int i,j;
    int upper_bound_color=0;
    int color_array[nodes][nodes];
    for(int i=0;i<nodes;i++)
    {
      for(int j=0; j<nodes; j++)
        color_array[i][j]=0;   ////once tum colorlar sifira esit
    }

	arr=new int[nodes];
    arr[0]=0;
    for(int i=1;i<nodes;i++)
        arr[i]=-1;

    i=0;
    while(i<nodes)
    {
        j=0;
        while(j<nodes)
        {
           if((arr[j]!=-1)&&(adjacency[i][j]==1))  ////komsu nodes larsa ve boyanmamislarsa
            color_array[i][arr[j]]=1;
            j++;
        }

        for(j=0;j<nodes;j++)
            if(color_array[i][j]==0)
                break;

        arr[i]=j;

        if(upper_bound_color<j)
			upper_bound_color=j;

        for(j=0;j<nodes;j++)
        {
           if((arr[j]!=-1)&&(adjacency[i][j]==1))
            color_array[i][arr[j]]=0;
        }
        i++;
    }
    return ++upper_bound_color;
}
